:coffeescript
  window.NAME = "interaction-design"
  window.VERSION = "1.0"

  window.emulateReading = ()->
    $(document).trigger "read-pressure", 
      data: [Math.random()*100, Math.random()*100, Math.random()*100, Math.random()*100]
  
  window.socket = null
  EMULATOR_ON = true

  class GestureCanvas
    @FAT_FINGER_OFFSET: 80
    @FONT: "Arial"
    @SCALE: 0.05
    constructor: (ops)->
      console.log "✓ Paperjs Functionality"
      this.name = "gesture"
      @_layout = "left-handed"
      @setup(ops)
    command: ()->
      commands = paper.project.getItems
        name: "command"
      if commands.length == 0
        return 0
      else
        return commands[0].setpoint
    setup: (ops)->
      scope = this
      canvas = ops.canvas[0]
      $(canvas)
        .attr('width', ops.canvas.parent().width())
        .attr('height', ops.canvas.parent().height())
      window.paper = new paper.PaperScope
      loadCustomLibraries()
      paper.setup canvas
      paper.view.zoom = 1
    
      @direction = new paper.Tool
        name: "direction"
        onMouseDown: (event)->
          paper.project.clear()
          @mdpt = event.point
          fat_finger_pt = event.point.clone()
          l = paper.project.view.bounds.topLeft.x
          r = paper.project.view.bounds.topRight.x
          @fat_direction = if l - event.point.x > event.point.x - r then 1 else -1
          fat_finger_pt.x += GestureCanvas.FAT_FINGER_OFFSET * @fat_direction
          @path = new paper.Path
            name: "command"
            segments: [fat_finger_pt, fat_finger_pt.clone()]
            strokeWidth: 4
            strokeColor: "blue"
        onMouseDrag: (event)->
          if not event.point.isInside(paper.view.bounds.expand(-15))
            return
          @path.lastSegment.point.y = event.point.y
          # Cleanup
          if @head then @head.remove()
          if @label then @label.remove()
          # Arrowhead Construction
          head_pt = event.point.clone()
          head_pt.x =  @path.lastSegment.point.x
          direction =  if @path.lastSegment.point.getDirectedAngle(@path.firstSegment.point) > 0 then 1 else -1
          @head = new paper.Path
            segments: [head_pt.add(new paper.Point(-10, direction * 20)), head_pt, head_pt.add(new paper.Point(10, direction * 20))]
          @head.style = @path.style
          # Labeling
          dir_label = if direction > 0 then "+ " else ""
          distance = @path.length * GestureCanvas.SCALE
          label = "error"
          if cb
            distance = direction * distance
            cb.next_setpoint = distance
            console.log "D", distance
            $('#send').addClass("enabled")
          else
            $('#send').addClass("disabled")


          # l = paper.project.view.bounds.topLeft.x
          # r = paper.project.view.bounds.topRight.x
          # x = @path.firstSegment.point.x
          

          # @label = new paper.PointText
          #   content: label
          #   fillColor: 'black'
          #   fontFamily: GestureCanvas.FONT
          #   fontWeight: 'bold'
          #   fontSize: 15
          #   position: @path.getPointAt(@path.length/2).add(new paper.Point(50 * @fat_direction, 0))
        
        onMouseUp: (event)->
          console.log "up"


      paper.view.update()

    clear: ->
      paper.project.clear()
      paper.view.update()
    Object.defineProperties @prototype, 
      layout:
        get: -> @_layout
        set: (value)-> 
          if value == @_layout then return
          @_layout = value
          if value == "left-handed"
            $(".state").remove().appendTo($("#input"))
            $('#controller').removeClass("right-handed")
            $('#controller').addClass("left-handed")
            $('[action="hand-toggle"]').html("CHANGE TO RIGHT-HAND")

          else if value == "right-handed"
            $(".state").remove().prependTo($("#input"))
            $('#controller').addClass("right-handed")
            $('#controller').removeClass("left-handed")
            $('[action="hand-toggle"]').html("CHANGE TO LEFT-HAND")

  
  $ -> 
    console.log "Interaction Design App Initialized"
    window.cb = new Compressable(window.socket)
    window.gc = new GestureCanvas
      canvas: $("canvas")
    # Enable Touch Interactions
    # $(document).on "contextmenu", (event)-> event.preventDefault(); return false;
    # Emergency Stop and Restart
    $('[action="restart"]').click ()-> window.cb.status = "ON"; 
    $('[action="emergency_stop"]').click ()-> 
      window.cb.status = "STOPPED"; 
      window.cb.next_setpoint = 0;
      gc.clear()
    # Limit Settings
    $('[action="set_ul"]').on "taphold", (event)-> window.cb.upper_limit = "–"; 
    $('[action="set_ll"]').on "taphold", (event)-> window.cb.lower_limit = "–"; 
    $('[action="set_ul"]').click ()-> window.cb.upper_limit = window.cb.pressure; 
    $('[action="set_ll"]').click ()-> window.cb.lower_limit = window.cb.pressure; 
    $('[action="hand-toggle"]').click ()-> window.gc.layout = if window.gc.layout == "right-handed" then "left-handed" else "right-handed"; 
    $('#send').click ()-> 
      window.cb.setpoint = cb.next_setpoint + cb.setpoint
      gc.clear()
    # Live pressure readings
    $(document).on "read-pressure", (event, msg)-> 
      sum = _.reduce(data = msg.data, ((x, memo)-> memo = memo + x), 0 )
      window.cb.pressure = sum / msg.data.length # average value of data packet

    # Emulation
    if(EMULATOR_ON) then setInterval(emulateReading, 250) # simulate a reading every 250 ms

    # Initial view update; needs to be called whenever state changes.
    cb.status = "ON"
    cb.upper_limit = 135
    cb.lower_limit = 121
    cb.setpoint = 120
    cb.next_setpoint = 0
    cb.pressure = 123

        
/ IoT Websocket

.ui.container.mobile
  .ui.segment.attached#server-control.connected
    %form.ui.form.server-control.tiny.equal.width
      .two.fields
        .two.field
          %label HAWS LOCAL
          .ui.labeled.input
            .ui.label ws://   
            %input.param{type:"text", name:"host", value:"192.168.1.4"}
          %label PORT
          %input.param{type:"number", name:"port", value: 3001}
        .field
          %label &nbsp;
          %button.connect.blue.ui.button.small.fluid{type:"submit"}
            CONNECT
  .ui.segment#controller.left-handed
    .cc.f
      .ui.vertical.buttons
        .ui.button.blue{action: "hand-toggle"} CHANGE TO RIGHT-HAND
        .ui.button.badged.massive.yellow{action: "set_ul"}
          SET UPPER LIMIT
          %span.badge 134

      .ui.segment#input.crc
        .canvas-container
          %label Scroll up or down to set a new target pressure. Hit send when ready.
          %canvas
          #send.icon.cc
            %i.icon.send
        .state.cc
          .reading.cc.blue
            %label.sublabel STATUS
            %label.status ON
          .reading.cc.blue
            %label.sublabel SET
            %label.setpoint 130
            %label.next_setpoint (+3)
          .reading.cc
            %label.sublabel PRESSURE
            %label.process_value 124
      .ui.vertical.buttons
        .ui.button.badged.massive.yellow.fluid{action: "set_ll"}
          SET LOWER LIMIT
          %span.badge 120
        .ui.button.massive.red.fluid{action: "emergency_stop"}
          EMERGENCY STOP
        .ui.button.massive.red.fluid{action: "restart"}
          RESTART

:scss
  .sublabel{
    font-size: 0.5em;
    font-weight: normal;
    margin-bottom: 4px;
  }
  .state{

  }
  .next_setpoint{
    color: #5CCA5B;
  }
  .right-handed .canvas-container label{
    pointer-events: none;
    position: absolute;
    top: 0px;
    left: 5px;
    font-size: 0.7em;
    line-height: 120%;
    margin: 20px 65px 20px 20px;
    font-weight: normal;
    background: rgba(255, 255, 255, 0.8);
  }
  .left-handed .canvas-container label{
    pointer-events: none;
    position: absolute;
    top: 0px;
    left: 5px;
    font-size: 0.7em;
    line-height: 120%;
    margin: 20px 20px 20px 65px;
    font-weight: normal;
    background: rgba(255, 255, 255, 0.8);
  }

  .canvas-container{
    width: 100%;
    height: 100%;
    position: relative;

  }
  .reading{
    margin-bottom: 8px;
    &.blue{
      color: #3A84EB;
    }
  }
  .left-handed #send{
    left: 5px;
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
  }
  .right-handed #send{
    right: 5px;
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
  }
  #send{
    position: absolute;
    top: 8px;
    height: calc(100% - 20px) !important;
    background: #5CCA5B;
    padding: 0px 10px;
    color: white;
  }

  #input{
    background: #333;
    width: calc(100% - 45px);
    
    canvas{
      width: 100%;
      height: 200px;
      background: white;
      margin: 8px;
      border-radius: 5px;
    }
    .state{
      width: 30%;
      color: white!important;
      font-size: 1.5em;
    }
  }
  .connected{
    display: none;
  }
  .ui.button.badged{
    display: flex !important;
    flex-flow: row nowrap !important;
    justify-content: space-between !important;
    align-items: center !important;
  }
  span.badge{
    padding: 6px 8px !important;
    background: white !important;
    border-radius: 15px !important;
    color: black !important;
    margin-left: 10px;
  }
  #controller{
    height: 100%;
    margin-top: 0px !important;
    background: #00A8E1;
  }
  .stopped .button[action="emergency_stop"]{
    display: none !important;
  }
  .stopped .button[action="restart"]{
    display: block !important;
    background: #5CCA5B;
  }
  .button[action="restart"]{
    display: none !important;
  }

  /* Disable buttons when stopped */
  .stopped .button:not([action="restart"]){
    background: #999 !important;
    color: #DDD !important;
    -webkit-tap-highlight-color: transparent;
    -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
    -webkit-touch-callout: none; /* iOS Safari */
      -webkit-user-select: none; /* Safari */
       -khtml-user-select: none; /* Konqueror HTML */
         -moz-user-select: none; /* Old versions of Firefox */
          -ms-user-select: none; /* Internet Explorer/Edge */
              user-select: none; /* Non-prefixed version, currently*/
    .badge{
      background: #DDD ! important;
      color: #333 !important;
    }
  }
  .stopped .canvas-container{
    display:none;
  }

 

        
